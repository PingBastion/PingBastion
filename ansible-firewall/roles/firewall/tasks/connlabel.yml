##############################################################################
# 0 ▸ Which ct_labels does the ruleset really use?
##############################################################################
- name: Collect raw ct_label strings
  set_fact:
    needed_labels_raw: >-
      {{
        firewall_cfg.dscp_classes
        | dict2items
        | selectattr('value.match.ct_label', 'defined')
        | map(attribute='value.match.ct_label')
        | list
        | unique
      }}

- name: Sanitise label names ('.' & '-' → '_')
  set_fact:
    needed_aliases: >-
      {{
        needed_labels_raw
        | map('replace', '.', '_')
        | map('replace', '-', '_')
        | list
      }}

##############################################################################
# 1 ▸ Netify dump once, build full alias→id dict
##############################################################################
- name: Dump Netify label map
  command: netifyd --dump-all
  register: netify_dump
  changed_when: false

- name: Build complete alias→id map from dump
  set_fact:
    alias_id_all: >-
      {{
        alias_id_all | default({}) | combine({
          (line.split(':', 1)[1] | trim
                                  | replace('.', '_')
                                  | replace('-', '_')):
          (line.split(':', 1)[0] | int)
        })
      }}
  loop: "{{ netify_dump.stdout_lines }}"
  loop_control:
    loop_var: line
  when: line is search(':')  # safer and clearer than string literal

##############################################################################
# 2 ▸ Keep only the aliases we actually need
##############################################################################
- name: Extract numeric IDs for needed aliases
  set_fact:
    alias_id_raw: >-
      {{
        alias_id_all
        | dict2items
        | selectattr('key', 'in', needed_aliases)
        | items2dict
      }}

- name: Fail if any needed label is missing in Netify dump
  fail:
    msg: >
      These ct_labels are used in dscp_classes but Netify did not export them:
      {{ needed_aliases | difference(alias_id_raw.keys()) }}
  when: needed_aliases | difference(alias_id_raw.keys())

##############################################################################
# 3 ▸ Remap IDs ≥128 into first free slots <128
##############################################################################
- name: Bits already ≤127
  set_fact:
    low_used: "{{ alias_id_raw.values() | select('lt', 128) | list }}"

- name: Free low-bit pool
  set_fact:
    free_low: "{{ range(0, 128) | difference(low_used) | list }}"

- name: Start final map with the already OK entries
  set_fact:
    alias_id_final: >-
      {{
        alias_id_raw
        | dict2items
        | selectattr('value', 'lt', 128)
        | items2dict
      }}

- name: Remap every high-ID label
  set_fact:
    alias_id_final: "{{ alias_id_final | combine({ item.key: free_low[0] }) }}"
    free_low: "{{ free_low[1:] }}"
  loop: "{{ alias_id_raw | dict2items | selectattr('value', 'ge', 128) }}"
  when: free_low | length > 0

- name: Abort if we ran out of slots
  fail:
    msg: >
      No free conntrack-label bits (0–127) left to map high-ID labels:
      {{ alias_id_raw | dict2items
                      | selectattr('value', 'ge', 128)
                      | map(attribute='key')
                      | list }}
      Either drop some DSCP classes or raise the kernel limit.
  when:
    - free_low | length == 0
    - alias_id_raw | dict2items | selectattr('value', 'ge', 128) | list | length > 0

##############################################################################
# 4 ▸ Render /etc/connlabel.conf via template
##############################################################################
- name: Render conntrack-label alias file for nftables
  template:
    src: connlabel.conf.j2
    dest: /etc/connlabel.conf
    owner: root
    group: root
    mode: '0644'
